<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <style>
        #map { height: 100vh; width: 100%; }
        /* å³éµé¸å–®çš„æ¨£å¼ */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        .context-menu div {
            padding: 8px 12px;
            cursor: pointer;
        }
        .context-menu div:hover {
            background: #eee;
        }
    </style>
</head>
<body>
    <div id="map"></div>


        <!-- è‡ªè¨‚å³éµé¸å–® -->
    <div id="contextMenu" class="context-menu">
        <div id="setStart">è¨­ç‚ºèµ·é»</div>
        <div id="setEnd">è¨­ç‚ºçµ‚é»</div>
        <div id="setManual">æ‰‹å‹•è·¯å¾‘</div>
    </div>
    <script>
        // Carto åœ°åœ–ä¾†æº
        var cartoLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        });

        // OpenStreetMap åœ°åœ–ä¾†æº
        var osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });

        // è¨­ç½®åœ°åœ–
        var map = L.map('map').setView([24.1735, 120.6736], 12);

        // é è¨­é¡¯ç¤º Carto åœ°åœ–
        cartoLayer.addTo(map);

        // å‰µå»ºåœ–å±¤æ§åˆ¶é¢æ¿
        L.control.layers({
            'Carto': cartoLayer,
            'OpenStreetMap': osmLayer
        }).addTo(map);

        // åˆå§‹åŒ– QWebChannelï¼Œè®“ JavaScript èƒ½èˆ‡ Python æºé€š
        new QWebChannel(qt.webChannelTransport, function(channel) {
            window.pybridge = channel.objects.pybridge;
        });

        let inLogMessage = false;  // ç”¨ä¾†é˜²æ­¢éè¿´

        console.log = function(message) {
            if (!inLogMessage) {   // åªæœ‰åœ¨ä¸æ˜¯éè¿´èª¿ç”¨çš„æƒ…æ³ä¸‹æ‰åŸ·è¡Œ
                inLogMessage = true;  // è¨­ç½®æ——æ¨™ç‚º trueï¼Œé˜²æ­¢éè¿´
                // å°‡è¨Šæ¯è½‰ç‚º UTF-8 ç·¨ç¢¼æ ¼å¼å‚³é
                pybridge.logMessage(message);
                window.console.log(message);   // åŒæ™‚é¡¯ç¤ºåœ¨ç€è¦½å™¨çš„é–‹ç™¼è€…å·¥å…·ä¸­
                inLogMessage = false;  // é‡ç½®æ——æ¨™
            }
        };

        
        // ç›£è½æ»‘é¼ å³éµé»æ“Šäº‹ä»¶ï¼Œå‚³é€ç¶“ç·¯åº¦åˆ° Python
        /*
        map.on("contextmenu", function (event) {
            let lat = event.latlng.lat.toFixed(6);
            let lng = event.latlng.lng.toFixed(6);
        
            console.log("Right-click at:", lat, lng);  // æ¸¬è©¦ç”¨
        
            if (window.pybridge) {
                window.pybridge.sendCoordinates(parseFloat(lat), parseFloat(lng));
            }
        });
        */


        // å³éµé¸å–® DOM
        var contextMenu = document.getElementById("contextMenu");
        var setStartBtn = document.getElementById("setStart");
        var setEndBtn = document.getElementById("setEnd");
        var setManualBtn = document.getElementById("setManual");



        var highlightIcon = L.icon({
            iconUrl: '/highlight-icon.png',
            iconSize: [50, 50],
            iconAnchor: [25, 50],
            popupAnchor: [1, -34]
        });


        // å„²å­˜æ‰€æœ‰æ¨™è¨˜
        var markers = {};
        var marker;
        
        var selectedMarker = null;//right clickç•¶å‰é¸æ“‡çš„æ¨™è¨˜
        function addMarker(lat, lng, name) {
            // ğŸ”¹ ç›´æ¥ç”¨ `name` ä½œç‚º key
            if (markers[name]) {
                markers[name].remove();
            }

            let marker = L.marker([lat, lng]).addTo(map)
                .bindPopup(`<b>${name}</b>`)
                .on("click", function () {
                    console.log(`selected : ${name}`);
                    window.pybridge.sendData(name);
                })
                .on("contextmenu", function (e) {  // å³éµäº‹ä»¶
                    selectedMarker = marker;
                    showContextMenu(e.originalEvent, name);
                });

            markers[name] = marker;  // ğŸ”¹ ä»¥ `name` å­˜å…¥
        }
        
        // é¡¯ç¤ºå³éµé¸å–®
        function showContextMenu(event, name) {
            event.preventDefault(); // é¿å…ç€è¦½å™¨é è¨­å³éµé¸å–®
            contextMenu.style.top = `${event.pageY}px`;
            contextMenu.style.left = `${event.pageX}px`;
            contextMenu.style.display = "block";
        }
        // è¨­å®šèµ·é»
        setStartBtn.addEventListener("click", function () {
            if (selectedMarker) {
                let markerName = selectedMarker.getPopup().getContent().replace("<b>", "").replace("</b>", ""); // è§£æ popup å…§å®¹
                window.pybridge.sendNode(markerName,1);
                alert(`å·²è¨­ç‚ºèµ·é»: ${markerName}`);
            }
            hideContextMenu();
        });

        // è¨­å®šçµ‚é»
        setEndBtn.addEventListener("click", function () {
            if (selectedMarker) {
                let markerName = selectedMarker.getPopup().getContent().replace("<b>", "").replace("</b>", ""); // è§£æ popup å…§å®¹
                window.pybridge.sendNode(markerName,2);
                alert(`å·²è¨­ç‚ºçµ‚é»: ${markerName}`);
            }
            hideContextMenu();
        });
        
        // æ‰‹å‹•è·¯å¾‘
        setManualBtn.addEventListener("click", function () {
            if (selectedMarker) {
                let markerName = selectedMarker.getPopup().getContent().replace("<b>", "").replace("</b>", ""); // è§£æ popup å…§å®¹
                window.pybridge.sendNode(markerName,3);
                //alert(`å·²è¨­ç‚ºçµ‚é»: ${markerName}`);
            }
            hideContextMenu();
        });
        
        // éš±è—é¸å–®
        function hideContextMenu() {
            contextMenu.style.display = "none";
        }

        // é»æ“Šåœ°åœ–å…¶ä»–åœ°æ–¹æ™‚é—œé–‰é¸å–®
        map.on("click", hideContextMenu);
        document.addEventListener("click", hideContextMenu);


        // **è®Šæ›´æ¨™è¨˜åœ–ç¤º**
        /*
        function highlightMarkers(locationNames) {
            for (const key in markers) {
                let marker = markers[key];
                let markerName = marker.getPopup().getContent().replace("<b>", "").replace("</b>", "");
                console.log(`highlighted : ${markerName}`);
                if (locationNames.includes(markerName)) {
                    marker.setIcon(highlightIcon);  // âœ… æ”¹è®Šåœ–ç¤º
                } else {
                    marker.setIcon(new L.Icon.Default());  // âœ… è®Šå›é è¨­åœ–ç¤º
                }
            }
        }
        */

        // **è®Šæ›´æ¨™è¨˜åœ–ç¤ºï¼ˆHighlightï¼‰**
        function highlightMarkers(name, icon) {
            if (icon==="Default") {
                // **æ¢å¾©é è¨­æ¨™è¨˜**
                if (markers[name]) {
                    markers[name].setIcon(new L.Icon.Default());
                }
            } else {
                // **é«˜äº®ç•¶å‰æ¨™è¨˜**

                if (markers[name]) {
                    markers[name].setIcon(highlightIcon);
                }
            }
        }

        // æ–°å¢ç§»é™¤æ¨™è¨˜å‡½å¼
        function removeMarker(name) {
                        
            if (markers[name]) {
                markers[name].remove();
                delete markers[name];
                console.log(`removed highlight : ${name}`);
            }
        }


        var edges = {};  // å­˜æ”¾æ‰€æœ‰ç¹ªè£½çš„ç·šæ¢ï¼Œkey ç‚º "startNode-endNode"

        function drawEdges(edgesData) {
            clearEdges();  // å…ˆæ¸…é™¤èˆŠç·šæ¢

            edgesData.forEach(function(edge) {
                var startNode = edge[0];
                var endNode = edge[1];

                if (markers[startNode] && markers[endNode]) {
                    let startCoords = markers[startNode].getLatLng();
                    let endCoords = markers[endNode].getLatLng();

                    if (startCoords && endCoords) {
                        var latlngs = [startCoords, endCoords];
                        let polyline = L.polyline(latlngs, {
                            color: 'lightgray',
                            weight: 2,
                            opacity: 0.7,
                            smoothFactor: 1.5
                        }).addTo(map);

                        // âœ… å„²å­˜ A-B å’Œ B-A å…©ç¨® keyï¼Œç¢ºä¿é›™å‘æŸ¥è©¢
                        let edgeKey1 = `${startNode}-${endNode}`;
                        let edgeKey2 = `${endNode}-${startNode}`;
                        edges[edgeKey1] = polyline;
                        edges[edgeKey2] = polyline;
                    }
                }
            });

            console.log(`${Object.keys(edges).length} edges drawn`);
        }



        function changeEdge(startNode, endNode, newColor, newWeight, newOpacity, newSmoothFactor) {
            let edgeKey = `${startNode}-${endNode}`;

            if (edges[edgeKey]) {
                edges[edgeKey].setStyle({
                    color: newColor, 
                    weight: newWeight,
                    opacity: newOpacity,
                    smoothFactor: newSmoothFactor
                });
                console.log(`Changed edge : ${startNode} -> ${endNode} as ${newColor}`);
            } else {
                console.log(`Can not find ${startNode} -> ${endNode} edge`);
            }
        }

        // æ¸…é™¤æ‰€æœ‰é€£ç·š
        function clearEdges() {
            Object.values(edges).forEach(edge => map.removeLayer(edge));  // âœ… éæ­·ç‰©ä»¶çš„å€¼
            edges = {};  // âœ… æ¸…ç©º edges
            console.log("Cleared edges");
        }




    </script>
</body>
</html>
